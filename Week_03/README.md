学习笔记

__2020/08/24 周一 （23:50~23:52） 心情：紧迫感__
## 总结
* 递归的实现；  
	```C++
	void Recursion (int level, (void *) data) {
		//递归终结条件
		if(level >MAX_LEVEL) {
			return;
		}
		
		//处理当前层逻辑
		Process((void*) data);
		
		//递归到下一层
		Recursion(level+1, (void *) data);
		
		//清扫当前层的（此处为递归完毕返回的处理）
		
	}
	```
* 递归的思维要点：  
	1. 不要人肉递归，要做到条件反射的写；  
	2. 找到最近重复子问题，可以想象，计算机语言最基本的就是条件分支，循环分支；  
	3. 数学归纳法；（这个算是解决此类问题的切入点，以此找到2的重复性规律）  

## 感想
无

***

__2020/08/25 周三 （23:50~00:36） 心情：紧迫感__
## 总结
* 递归的实践
	“括号生成”问题，虽说不要去进行人肉递归，但是不人肉递归的话，难以理解性记忆。最开始不加判断条件，递归函数如下所示：
	```C++
	void Recurison(int level, int maxLevel, string &s) {
		//终结条件
		if(level >= maxLevel) {
			cout << "tmS = " << s << endl;      
			return ;
		}
		//逻辑处理

		//递归下层
		Recurison(level+1, maxLevel, s + "(");
		Recurison(level+1, maxLevel, s + ")");
		//处理当前层
	}	
	```
	+ 从这里来看，由于括号要么是左括号，要么是右括号，按照此条件，因此可以生成一颗完全二叉树，除根保存"("外，左节点保存"("，右节点保存")"。
	+ n则代表二叉树的深度，不考虑重复性的话，每一层都可裂变成2^n种情况；
	+ 由于括号均是从"("开始，因此每次应该优先遍历根（前序遍历），到每一个子节点输出（保存）结果；由此可得到上述代码；
	+ 为了获取有效的括号对，因此在每层新增记录"("和")"的个数，只有当"("个数与")"个数完全相等才允许输出；新思路代码如下:
	```C++
	
	```  
## 感想
太晚，明天继续分析，进度开始有点跟不上。时间不够。

***

__2020/08/27 周四 （23:50~00:36） 心情：紧迫感__
## 总结
* 继续分析“括号生成问题”  
	此前只是将所有可能值给遍历出来了。大脑中可以将其想象成前述的完全二叉树；但为了满足题目的条件，有效括号对的含义，左括号一定要等于右括号。改造如下：
	```C+++
	void Recursion(int left, int right, int n, string &s) {
		//终结条件，当左括号和右括号均等于括号对数n时，可以输出；
		if((left == n) && (right == n)) {
			cout << s << endl;
		}
		//逻辑处理
		
		//递归下层
		//处理左括号是否要向下递归，若是左括号不超过n，则可以向下遍历，否则处理左括号
		if(left < n) {
			Recurison(left+1, right, n, s+"(");
		}
		else {//说明子树已经到底了 }
		
		if((left > right) && (right < n)) {
			Recurison(left, right+1, n, s+"(");
		}
		else {//说明子树已经到底了}
		
		//处理当前层
	}
	```
	从以上所有代码逻辑可以看出，首先要找到递归的终结条件，以及递归下层如何按照要求处理可以持续递归到终结条件。然后再从这个递归过程中，筛选出准确的解。  
* 验证二叉搜索树BST(Binary Search Tree)
	+ 二叉树的定义：左子树的节点存在，则左子树的所有左节点的值均小于其根节点的值；若右子树存在，则右子树的所有右节点的值均大于其根节点的值，注意是树的所有节点，而不仅仅是左右节点；
	+ BST的特性导致其中序遍历的值是有序递增的。  

## 感想
二叉搜索树相关题目未继续。


***

__2020/08/28 周五 （23:50~00:36） 心情：无所适从__
## 总结
* 默写递归模板
	```C++
	void recurision(int level, int maxLevel) {
		//终极条件
		if(level >= maxLevel) {
			cout << level << endl;
		}
		//当前层级逻辑处理
		
		//递归下一层
		recurision(level+1, maxLevel);
		//递归后当前层级清理
	}
	```
* 分治
	即是将大的问题分解成小的问题；类似于递归，分支的终极条件就是不再有子问题了，即子节点。分治的关键是如何将大问题分解成多个子问题。  
* 回溯
	试错。
	
## 感想
听课有些吃力，做题有些懵逼。