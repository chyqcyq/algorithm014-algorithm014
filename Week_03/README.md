学习笔记

__2020/08/24 周一 （23:50~23:52） 心情：紧迫感__
## 总结
* 递归的实现；  
	```C++
	void Recursion (int level, (void *) data) {
		//递归终结条件
		if(level >MAX_LEVEL) {
			return;
		}
		
		//处理当前层逻辑
		Process((void*) data);
		
		//递归到下一层
		Recursion(level+1, (void *) data);
		
		//清扫当前层的（此处为递归完毕返回的处理）
		
	}
	```
* 递归的思维要点：  
	1. 不要人肉递归，要做到条件反射的写；  
	2. 找到最近重复子问题，可以想象，计算机语言最基本的就是条件分支，循环分支；  
	3. 数学归纳法；（这个算是解决此类问题的切入点，以此找到2的重复性规律）  

## 感想
无

***

__2020/08/25 周三 （23:50~00:36） 心情：紧迫感__
## 总结
* 递归的实践
	“括号生成”问题，虽说不要去进行人肉递归，但是不人肉递归的话，难以理解性记忆。最开始不加判断条件，递归函数如下所示：
	```C++
	void Recurison(int level, int maxLevel, string &s) {
		//终结条件
		if(level >= maxLevel) {
			cout << "tmS = " << s << endl;      
			return ;
		}
		//逻辑处理

		//递归下层
		Recurison(level+1, maxLevel, s + "(");
		Recurison(level+1, maxLevel, s + ")");
		//处理当前层
	}	
	```
	+ 从这里来看，由于括号要么是左括号，要么是右括号，按照此条件，因此可以生成一颗完全二叉树，除根保存"("外，左节点保存"("，右节点保存")"。
	+ n则代表二叉树的深度，不考虑重复性的话，每一层都可裂变成2^n种情况；
	+ 由于括号均是从"("开始，因此每次应该优先遍历根（前序遍历），到每一个子节点输出（保存）结果；由此可得到上述代码；
	+ 为了获取有效的括号对，因此在每层新增记录"("和")"的个数，只有当"("个数与")"个数完全相等才允许输出；新思路代码如下:
	```C++
	
	```
## 感想
太晚，明天继续分析，进度开始有点跟不上。时间不够。
	
	